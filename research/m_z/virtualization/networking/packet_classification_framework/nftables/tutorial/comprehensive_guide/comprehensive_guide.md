# **[comprehensive guide](https://www.linkedin.com/pulse/comprehensive-guide-nftables-leading-packet-filtering-arash-shirvar/)**

## 1.1 What is packet filtering?

Every local network that is connected to other external networks should be carefully monitored and inspected by using a packet filtering or a reliable firewall node that can be an application or dedicated hardware at the perimeter of the network. With the help of a firewall, every incoming and outgoing packet traversing a network medium can be under strict control and monitor in terms of the ports, protocols, and source and destination destined to be sent or received by another node in a network. In the event of any discrepancy in network packets due to any malicious attacks, this packet filtering node is capable of deciding to either allow or drop the packets to stop them from traversing further into a network hence the name firewall based on some predefined rules.  Concerning the location of a firewall, it is widely acknowledged that it should be placed on the front line of the defense layer of a network to effectively serve the aforementioned purpose as illustrated in the following diagram.

![](https://media.licdn.com/dms/image/C4E12AQEi28SZYa5HJg/article-inline_image-shrink_400_744/0/1595554740412?e=1723680000&v=beta&t=VUjlfPwDG3082iyB2tEjGosCGe2-1koiiDbuI8pwpfc)

IPS can stand for Intrusion Prevention System, which is a network security tool that monitors for malicious activity and takes action to prevent it. IPS can be software or a hardware device. It works by looking for traffic patterns or attack characteristics in real-time network activity. When it identifies something suspicious, it generates alerts and blocks the attack. IPS can also terminate dangerous connections, remove malicious content, or trigger other security devices.

A firewall typically allows or denies traffic based on ports or the source/destination addresses. In contrast, IPS compares traffic patterns to signatures and allows or drops packets based on any signature matches found.

## 1.2 What is Netfilter?

As stated by Netfilter organization, Netfilter is a packet filtering framework inside the Linux 2.4.x and later kernel series. To do its jobs, Netfilter provides an application named Iptables a common packet filtering application that is associated with Netfilter in Linux kernel. Iptables is a tabled-based system for providing the ability to define firewall rules for filtering and monitoring incoming and outgoing packets. Technically, Netfilter provides some network operations or a set of hooks inside the Linux kernel that allow iptables control and monitor all network packets traversing the network stack in Linux. Every program that works with these hooks will be enabled to interact with traffic flow when a packet triggers a specific hook (2014). Gradually, however, due to the limitations of iptables, high complexity, and less scalability, a new framework was introduced named nftables with the newer command-line tool called nft, based on Netfilter infrastructure including the hook infrastructure.

## 2. What is nftables?

According to Netfilter project, nftables is an open-source and free packet classification framework, released in 2014 for Linux, and provides packet filtering, and network address translation (NAT). Nftables, basically, is a replacement for and successor to iptables that is a packet-filtering program like nftables for Linux to define rules for filtering and logging network traffic activity (2017). Nftables is gaining popularity in that it has some advantages over iptables including better and easier scalability and performance that make it an ideal choice for packet filtering in our networks. Thankfully, nftables can work with different address families from IPv4, IPv6 to ARP, and netdev that is a family for ingress hook explained later within its framework compared to iptables requiring using different tools to manage different address families. Further, nftables syntax is simpler to use, more consistent and compact with no protocol-specific extensions. It can be shown by comparing both nft and iptables command tools to add a rule.

```bash
nft add rule ip filter <chain-name> ip daddr 10.0.0.1 accept

iptables -A <chain-name> -d 10.0.0.1 -j ACCEPT
```

## 2.1 Nftables hooks

Every packet that enters a node with active nftables whether incoming or outgoing will trigger some hooks as it traverses through the Linux kernel’s networking stack. Linux kernel allows rules that are associated with these hooks to interact with the network traffic. Nftables like its parent, Netfilter, has five hooks including prerouting, input, output, post routing, forward, and ingress according to Netfilter (2019).

When traffic flow goes into a local machine, first, it faces the prerouting hook and then input hook. Next, the traffic generated by the local machine’s processes follows the output hook and then the postrouting hook as shown in the next figure.

![](https://media.licdn.com/dms/image/C4E12AQEdJeJUNglOHw/article-inline_image-shrink_1000_1488/0/1595554785169?e=1723680000&v=beta&t=cflrlPSfXwbEzfpCJS6mvd0wz-WR8OPHSLmhkwAknlg)

The packets destined to your network but are not addressed to the local node will face the forward hook after following prerouting and then postrouting path. Ingress hook, however, as a new hook in nftables, is a hook that is placed before all the hooks behind the prerouting hook and can filter traffic on layer 2 OSI model. With this hook, therefore, early filtering policies can be defined (2019).

## 3. Nftables pre-configurations

Nftables configuration consists of hierarchical modules including tables, chains, sets and rules. To configure nftables, first, it is necessary to check the current content of nftables configuration file using the following command. By default, nftables configurations are located in /etc/nftables.conf.

```bash
ssh brent@repsys11
cat /etc/nftables.conf
#!/usr/sbin/nft -f

flush ruleset

table inet filter {
 chain input {
  type filter hook input priority 0;
 }
 chain forward {
  type filter hook forward priority 0;
 }
 chain output {
  type filter hook output priority 0;
 }
}

sudo nft list ruleset

table inet lxd {
 chain pstrt.mpbr0 {
  type nat hook postrouting priority srcnat; policy accept;
  ip saddr 10.161.38.0/24 ip daddr != 10.161.38.0/24 masquerade
  ip6 saddr fd42:b403:217:3a62::/64 ip6 daddr != fd42:b403:217:3a62::/64 masquerade
 }

 chain fwd.mpbr0 {
  type filter hook forward priority filter; policy accept;
  ip version 4 oifname "mpbr0" accept
  ip version 4 iifname "mpbr0" accept
  ip6 version 6 oifname "mpbr0" accept
  ip6 version 6 iifname "mpbr0" accept
 }

 chain in.mpbr0 {
  type filter hook input priority filter; policy accept;
  iifname "mpbr0" tcp dport 53 accept
  iifname "mpbr0" udp dport 53 accept
  iifname "mpbr0" icmp type { destination-unreachable, time-exceeded, parameter-problem } accept
  iifname "mpbr0" udp dport 67 accept
  iifname "mpbr0" icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, nd-router-solicit, nd-neighbor-solicit, nd-neighbor-advert, mld2-listener-report } accept
  iifname "mpbr0" udp dport 547 accept
 }

 chain out.mpbr0 {
  type filter hook output priority filter; policy accept;
  oifname "mpbr0" tcp sport 53 accept
  oifname "mpbr0" udp sport 53 accept
  oifname "mpbr0" icmp type { destination-unreachable, time-exceeded, parameter-problem } accept
  oifname "mpbr0" udp sport 67 accept
  oifname "mpbr0" icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, echo-request, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, mld2-listener-report } accept
  oifname "mpbr0" udp sport 547 accept
 }
}
```

Note that each rule has a certain number called handle, by using -a or --handle all rules’ handles are also shown. These numbers are important as they can be used to remove a specific rule to add a rule before or after a specific rule with a specific handle number.

```nft -a list ruleset```

Second) in case you need to clear all the current data in the configuration file and then create your nftables modules, the next command should be followed.

```nft flush ruleset```

## 5. Nftables modules

### 5.1 Tables

A table is at the apex of the ruleset as a container in which chains that are the containers for rules are kept. In terms of operations that can be done on a table, adding, deleting, displaying, or listing, and emptying or flushing can be mentioned. Considering the importance of tables, the hierarchical overview of nftables’s structure is as follows:

Tables > Chains > Rules

When adding a table, chain, and a rule either by using nft command tools or directly writing them inside the nftablrs configuration file, the following structure can be seen in the nftables configuration file as shown in the next figure. As it is clear from this example below, a table followed by an address family, that is “inet” explained later, and then it is followed by its defined name that is “table1” with an open and a close curly bracket.

![](https://media.licdn.com/dms/image/C4E12AQH2PTa9jgTSLQ/article-inline_image-shrink_1000_1488/0/1595554863963?e=1723680000&v=beta&t=3PFo0QTloC8WdeKeqnS_XSCrohHHCAbQOCls6xoxE94)

## 5.2 Address Families

Address families determine the type of incoming and outgoing packets processed by nftables. For each address family, the Linux kernel contains specific hooks at different stages of the packet processing paths, which invoke nftables to decide either allow or drop a packet only if relevant rules for these hooks such as input or output are defined. These address families are as follows:

- **ip:** IPv4 address family.
- **ip6:** IPv6 address family.
- **inet:** Supports Both IPv4 and IPv6 address families.
- **arp:** ARP address family, handling IPv4 ARP packets at layer 2 OSI model.
- **bridge:** Bridge address family, handling packets traversing a bridge device at layer 2.
- **netdev:** Netdev address family, handling packets from ingress hook working before layer 3.

Table with netdev family, be means of ingress hook, allows early filtering traffic before they reach other filters below layer 3 on the OSI model. netdev family with ingress hook is an ideal stage to drop packets that result from DDOS attacks since this hook works very early in the packet path of networking.

## 5.3 Chains

Chains are a container of rules and are located inside a table created beforehand. Chains can be a base chain that can control packets destined into a node and has a hook whereas a non-base chain is a chain that is used for organization of chains and has no hook hence no control on packets. Similar to a table, all operational activities can be done on a chain in addition to renaming a chain. Chains should be followed by a name and an open and a close curly bracket. They also come with a type, a hook, a priority, and a policy that must be defined when creating a chain as shown in the next figure.

Chain chain-name { type <type> hook <hook> priority <priority> ; policy <policy> ; }

![](https://media.licdn.com/dms/image/C4E12AQFdVnsFuLkuNQ/article-inline_image-shrink_1000_1488/0/1595554904614?e=1723680000&v=beta&t=ZvrOd9Dwc-o2nV15BYUSY0Z8DEbwXjNEfOYrJBcDND8)

## 5.3.1 Chains types

- **Filter:** This is a standard chain type and supports all address families namely ARP, bridge, IP, IP6, and inet and hooks.
- **Route:** It supports only IP and IPv6 address families and only output hook. If relevant parts of the IP header have changed, a new route lookup is performed.
- **Nat:** It can perform Network Address Translation, and only supports IP and IPv6 address families. prerouting, input, output, postrouting hooks are also supported.

## 5.3.2 Chains hooks

A Hook in a chain refers to a specific stage that a packet is being processed through a Linux kernel based on defined rules. These hooks are ingress, prerouting, input, forward, output, and postrouting and are explaind in detail in the next section. Prerouting, input, forward, output, and postrouting hook can also support IP, IPv6, and inet address families. To support arp address family, input, output hooks can be used while for netdev family, ingress hook should be used.

- **Prerouting:** All packets entering a node are processed by this hook. It is invoked before the routing process and is used for early filtering or changing packet attributes that affect routing.
- **Input:** This hook are executed after the routing decision. Packets delivered to a local system are processed by this hook.
- **Forward:** This hook also happens after the routing decision. Packets that are not directed to the local machine are processed by this hook.
- **Output:** This hook controls the packets that are originated from processes in a local machine.
- **Postrouting:** This hook is used for the packets leaving a local system after the routing decision
- **Ingress (only available at the netdev family):** Since Linux kernel 4.2, traffic can be filtered before layer 3 and way before prerouting, after the packets are passed up from a NIC driver.

## 5.4 Policies

Chains have to have their policies by which packets are treated to be either dropped or accepted by default. These policy values can be “accept”, which is the default policy, or “drop”. Accept policy means that all the network packets based on their locations defined by the hook should be accepted by default whereas drop policy means that by default all network packets must be dropped based on their locations defined by the hook in a chain and then based on defined rules inside a chain will be accepted or otherwise.

## 5.6 Rules

Rules are the actions that control the incoming and outgoing packets based on the defined hooks in a chain. If a rule inside a chain matches with a packet based on the stage derived from their hooks, the packet is dropped or accepted. A rule is evaluated from left to right in a way that when the first statement matches, it continues with the next parts of a rule, but if not, the next rule will be evaluated. The structure of a rule includes matches and statements which is as follows:

<matches> <statements>

For example:

iifname “interface name” Policy: <accept or drop>

## 5.6.1 Matches

Matches are those filters that enable a rule to filter certain packets. Some important matches with their possible formats are briefly as follows:

Ip saddr <ip source address>
Ip daddr <ip destination address>
tcp / udp dport <destination port>
tcp / udp sport < source port>
tcp flags <flags>
ICMP type <type>
iifname <input interface name>
oifname <output interface name>
protocol <protocol>

## 5.6.2 Statements

A statement is the defined action performed once a packet matches a match(es) defined by a rule. Statemets comprise of verdict, log, and counter statements.

Verdict statements

The verdict statement alters the control flow in the ruleset and issues policy decisions for packets. The valid verdict statements are:

- **accept:** Accept the packet and stop the remaining rules evaluation.
- **drop:** Drop the packet and stop the remaining rules evaluation.
- **queue:** Queue the packet to userspace and stop the remaining rules evaluation.
- **continue:** Continue the ruleset evaluation with the next rule.
- **jump <chain>:** Continue at the first rule of <chain>. It will continue to evaluate the next rules to finally return to the last position or a return statement is issued.
- **return:** Return from the current chain and continue at the next rule of the last chain. In a base chain, it is equivalent to accept
- **goto <chain>:** Similar to jump, but after finishing the rules in <chain>, the evaluation will continue to evaluate the next chains instead of waiting for a return to the last chain.

## 6. Nftables configuration

There are three ways to define nftables modules:

### 1. Using nft command-line tools to create tables, chains, and rules, etc

In this approach, once adding or editing a module, any changes apply immediately to the nftables file running into the memory.

To make all the changes permanent in the event of restarting the machine, the following command should be issued.

```nft list ruleset > /etc/nftables.conf```

To make all the changes permanent in the event of restarting the service (nftables), the following command should be used.

```nft list ruleset > /root/nftables.conf```

### 2. Using nftables.conf file to directly define tables, chains, and rules

In this approach, after adding or editing a module and then saving the file, any changes will be saves into the nftables file inside the storage of a system and do not apply immediately to the nftables file running into the memory. To replace the old file running in the memory with the new one, the following commands must be issued.

```bash
systemctl stop nftables

systemctl start nftables
```

### 3. Creating a script to define tables, chains, and rules

Creating an executable script has several merits over using other methods to create and maintain nftables elements. These are:

- The atomic execution of a script file: meaning that if there is an error, the nftables prevent the execution of the whole file.
- Add comments inside a script file to save in nftables.conf
- Define variables inside a script file to save in nftables.conf
- Include other ruleset files inside a script file to save in nftables.conf

## 6.1 Table

### 1. Creating tables by nft shell script

```bash
# To manage, create, and edit tables based on nft shell script, the following commands should be considered.

# [ ] = optinal options

# <family> = family address

% nft list tables

% nft list table [<family>] <name>

% nft (add | delete | flush) table [<family>] <name>

# Disable a table temporarily

% nft add table [<family>] <name> flags dormant

# Make the table active again

% add table [<family>] <name>
```

### 2. Creating tables by Nftables.conf

To create tables directly into the nftables.conf, the following scripts should be followed.

```
table [<family>] <name> {

 chain <name> {

   type filter hook input priority 0; policy drop;

 } }
```

### 3. Creating tables by nftables script environment

To create tables based on nftables script environment, the following commands that are similar to the previous model should be considered.

Note that, the script file should have .nft as its file format and must be executable to be executed by nftables. To run the file, the full address of the file should be run and then all the contents of the file will be added to nftables ruleset in case of no error.

```bash
#!/usr/sbin/nft -f

# Flush the rule set

flush ruleset

table [<family>] <name> {

 chain <name> {

   type filter hook input priority 0; policy drop;

 } }
```

## 6.2 Chain

### 1. Creating chains by nft shell script

1.1 To manage, create, and edit base chains based on nft shell script, the following commands should be followed.

```bash
% nft (add | create) chain <family> <table> <name> { type <type> hook <hook> priority <priority> \; policy <policy> \; }

# When defining ingress as a chain’s hook, defining a device is necessary!

% nft (add | create) chain <family> <table> <name> { type <type> hook ingress device <interface> priority <priority> \; policy <policy> \; }

% nft (delete | list | flush) chain <family> <table> <name>

% nft rename chain <family> <table> <name> <newname>
```

1.2 To manage, create, and edit non-base (Regular) chains based on nft shell script, the following commands should be followed. This chain does not monitor any traffic since it is not attached to any hook, but it is useful to arrange the rule-set in a tree of chains using the jump to chain action.

```bash
% nft add chain <family> <table-name> <chain-name>

# Create a rule to jump to a non-based chain when facing TCP packets

% nft add rule <family> <table-name> input ip protocol tcp jump <nonbased-chain-name>

# The structre after creating a non-based chain

table ip table-name {

       chain input {

                type filter hook input priority 0;

                ip protocol tcp jump nonbased-chain-name

       }

       chain nonbased-chain-name {

       } }

```

## 2. Creating chains by nftables.conf

```bash
table ip table-name {

       chain <chain-name1> {

               type <type> hook <hook> priority <priority>; policy <policy>;

               rule1 ...

                rule2 ...

       }

       chain <chain-name2> {

               type <type> hook <hook> priority <priority>; policy <policy>;

               rule1 ...

                rule2 ...

       } }
```

## 6.3 rules

....

To have the complete version of this article providing you with more detailed information and advanced features of nftables, please refer to easillyy.com. This article can be also subject to edit and rectify.
