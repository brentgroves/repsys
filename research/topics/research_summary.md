# Research Summary

**[Current Status](../../development/status/weekly/current_status.md)**\
**[Research List](../../research/research_list.md)**\
**[Back Main](../../README.md)**

| Research                                                                                          | Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|---------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **[How should we notify a customer there report is finished?](./notification_platforms.md)**            | Use HTTP2 push notifications because there is a industry standard way of knowing who you are sending messages to.                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **[Which K8s Gateway should we use?](k8s_gateway.md)**                                            | Use **Istio** which leverages **[Envoy](https://tetrate.io/what-is-envoy-proxy/)** proxy server technology to support about every possible Application Delivery Controller, **[ADC](https://kemptechnologies.com/blog/what-is-an-application-delivery-controller-(adc)-and-why-should-you-use-one)**, feature such as retries, circuit breakers, rate limiting, tls termination, and metrics.                                                                                                                                                                    |
| **[Should the report system use REST or gRPC based micro services?](rest_vs_grpc.md#summary)**    | Either REST or gRPC would be a perfectly acceptable way of implementing our micro services. The deciding factor for me was that gRPC gives you HTTP 2 feature support such as streaming and an IDL language enabling you to generate client code in any language using the protoc compiler so will try out gRPC micro services.                                                                                                                                                                                                                                  |
| **[How should our Micro Services communicate with each other?](./microservice_communication.md)** | In the Tool Tracker we used a message broker to make east-west requests of our micro services. Unfortunately, the message broker approach to request services is difficult to secure in a standard and uncomplicated way. Fortunately, we can use the Envoy proxy features of our Istio gateway to secure our micro services by enabling the automatic sidecar creation feature of Istio.  By doing this we will have a TLS secured request channel between our micro services without having to write any additional code using a well accepted design pattern. |

## Why Istio Gateway

It simplifies using Envoy.

![envoy](https://www.envoyproxy.io/docs/envoy/latest/_images/service_to_service.svg)

- **Advanced load balancing:** Load balancing among different components in a distributed system is a complex problem. Because Envoy is a self contained proxy instead of a library, it is able to implement advanced load balancing techniques in a single place and have them be accessible to any application. Currently Envoy includes support for **automatic retries**, **circuit breaking**, **global rate limiting** via an external rate limiting service, **request shadowing**, and **outlier detection**. Future support is planned for **request racing**.

**Front/edge proxy support:** There is substantial benefit in using the same software at the edge (observability, management, identical service discovery and load balancing algorithms, etc.). Envoy has a feature set that makes it well suited as an edge proxy for most modern web application use cases. This includes **TLS termination**, **HTTP/1.1 HTTP/2 and HTTP/3 support**, as well as **HTTP L7 routing**.

**Best in class observability:** As stated above, **the primary goal of Envoy is to make the network transparent**. However, problems occur both at the network level and at the application level. Envoy includes robust statistics support for all subsystems. statsd (and compatible providers) is the currently supported statistics sink, though plugging in a different one would not be difficult. Statistics are also viewable via the administration port. Envoy also supports distributed tracing via thirdparty providers.

## What are the other differences between HTTP/2 and HTTP/1.1 that impact performance?

**Multiplexing:** HTTP/1.1 loads resources one after the other, so if one resource cannot be loaded, it blocks all the other resources behind it. In contrast, HTTP/2 is able to use a single TCP connection to send multiple streams of data at once so that no one resource blocks any other resource. HTTP/2 does this by splitting data into binary-code messages and numbering these messages so that the client knows which stream each binary message belongs to.

**Server push:** Typically, a server only serves content to a client device if the client asks for it. However, this approach is not always practical for modern webpages, which often involve several dozen separate resources that the client must request. HTTP/2 solves this problem by allowing a server to "push" content to a client before the client asks for it. The server also sends a message letting the client know what pushed content to expect â€“ like if Bob had sent Alice a Table of Contents of his novel before sending the whole thing.

**Header compression:** Small files load more quickly than large ones. To speed up web performance, both HTTP/1.1 and HTTP/2 compress HTTP messages to make them smaller. However, HTTP/2 uses a more advanced compression method called HPACK that eliminates redundant information in HTTP header packets. This eliminates a few bytes from every HTTP packet. Given the volume of HTTP packets involved in loading even a single webpage, those bytes add up quickly, resulting in faster loading.

## What is gRPC

**gRPC support:** gRPC is an RPC framework from Google that uses HTTP/2 or above as the underlying multiplexed transport. Envoy supports all of the HTTP/2 features required to be used as the routing and load balancing substrate for gRPC requests and responses. The two systems are very complementary.
