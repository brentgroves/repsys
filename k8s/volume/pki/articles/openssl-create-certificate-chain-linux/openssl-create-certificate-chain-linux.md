https://www.golinuxcloud.com/openssl-create-certificate-chain-linux

OpenSSL encrypted data with salted password (Optional)
When we create private key for Root CA certificate, we have an option to either use encryption for private key or create key without any encryption. As if we choose to create private key with encryption such as 3DES, AES then you will have to provide a passphrase every time you try to access the private key.

I have already written another article with the steps for openssl encd data with salted password to encrypt the password file.

In this article we we will use RSA key which will not encrypt the private key, but you can decide to use AES or 3DES as your preferred algorithm.

Step 1: Create OpenSSL Root CA directory structure
We can also create CA bundle with all the certificates without creating any directory structure and using some manual tweaks but let us follow the long procedure to better understanding. In RHEL/CentOS 7/8 the default location for all the certificates are under /etc/pki/tls. But for this article we will create a new directory structure /root/myCA/ to store our certificates.

Create a directory structure to store the CA files, certificates, and private keys:

bash
mkdir -p ~/src/ca/rootCA/{certs,crl,newcerts,private,csr}
mkdir -p ~/src/ca/intermediateCA/{certs,crl,newcerts,private,csr}
Each directory in your Certificate Authority (CA) folder structure serves a specific purpose:

certs: This directory contains the certificates generated and signed by the CA. For the root CA, this includes the root CA certificate itself. For the intermediate CA, this includes the intermediate CA certificate and any server or client certificates signed by the intermediate CA.
crl: The Certificate Revocation List (CRL) directory contains the CRLs generated by the CA. A CRL is a list of certificates that have been revoked by the CA before their expiration date.
newcerts: This directory stores a copy of each certificate signed by the CA, with the certificate's serial number as the file name. It helps maintain a backup of all issued certificates.
private: This directory contains the private keys for the CA, including the root CA and intermediate CA private keys. These keys are used to sign certificates and CRLs. The private keys should be kept secure and not shared.

The majority of the files that the CA uses are visible to anyone on the system or at least to anyone who makes any use of the certificates issued by our CA. The one notable exception is the CA certificate’s private key. The private key should never be disclosed to anyone not authorized to issue a certificate or CRL from our CA. The private key should be stored in hardware, or at least on a machine that is never put on a network

# don't do this initializing of the serial number because we want openssl to generate a very long serial number
A serial file is used to keep track of the last serial number that was used to issue a certificate. It’s important that no two certificates ever be issued with the same serial number from the same CA. OpenSSL is somewhat quirky about how it handles this file. It expects the value to be in hex, and it must contain at least two digits. By setting the initial value to 1000, we ensure that the serial numbers start from 1000 and increment for each subsequent certificate issued.

echo 1000 > ~/src/ca/rootCA/serial
echo 1000 > ~/src/ca/intermediateCA/serial
# do this to initialize a serial number
https://www.openssl.org/docs/man3.0/man1/openssl-x509.html#CAserial-filename
-CAserial filename
Sets the CA serial number file to use.
When creating a certificate with this option and with the -CA option, the certificate serial number is stored in the given file. This file consists of one line containing an even number of hex digits with the serial number used last time. After reading this number, it is incremented and used, and the file is updated.
The default filename consists of the CA certificate file base name with .srl appended. For example if the CA certificate file is called mycacert.pem it expects to find a serial number file called mycacert.srl.
If the -CA option is specified and neither <-CAserial> or <-CAcreateserial> is given and the default serial number file does not exist, a random number is generated; this is the recommended practice.
-CAcreateserial
With this option and the -CA option the CA serial number file is created if it does not exist. A random number is generated, used for the certificate, and saved into the serial number file determined as described above.

# crlnumber (did not do this yet)
A crlnumber is a configuration directive specifying the file that contains the current CRL number. The CRL number is a unique integer that is incremented each time a new Certificate Revocation List (CRL) is generated. This helps in tracking the latest CRL issued by the CA and ensuring that CRLs are issued in a proper sequence. We have given a random digit in our crlnumber file which will be used to keep track of all certs which are revocated.

bash
echo 0100 > ~/src/ca/rootCA/crlnumber 
echo 0100 > ~/src/ca/intermediateCA/crlnumber

# index.txt
Next we will create index.txt file which is a database of sorts that keeps track of the certificates that have been issued by the CA. Each line in the index.txt file represents a certificate and contains information such as the certificate's status (e.g., valid, revoked), the certificate's expiration date, the certificate's serial number, and the certificate subject's distinguished name (DN).

Since no certificates have been issued at this point and OpenSSL 'ca' requires that the file exist, we’ll simply create an empty file.
openssl x509 does not create this database but creates an srl file with the serial number in it.
bash
touch ~/src/ca/rootCA/index.txt
touch ~/src/ca/intermediateCA/index.txt

# Step 2: Configure openssl.cnf for Root and Intermediate CA Certificate
We will create 2 separate openssl.cnf file (each for root and intermediate CA).

Here is our openssl_root.cnf file:
If you are planning to add more intermediate CA certificate then I would recommend to give either a higher value for pathlen or just remove it in the following section. As pathlen restricts creating any further intermediate CA in the chain. You may also create another section v3_intermediate_ca_n and there you can add pathlen: 0 to make sure that is the last intermediate certificate in your chain.


# Step 3: Generate the root CA key pair and certificate
Create an RSA key pair for the root CA without a password:


bash
openssl genrsa -des3 -passout file:/home/brent/src/ca/mypass.enc -out ~/src/ca/rootCA/private/ca.key.pem 4096
chmod 400 ~/src/ca/rootCA/private/ca.key.pem
IMPORTANT NOTE:
If this key is compromised, the integrity of your CA is compromised, which essentially means that any certificates issued, whether they were issued before the key was compromised or after, can no longer be trusted.
We will use openssl command to view the content of private key:

bash
openssl rsa -passin file:/home/brent/src/ca/mypass.enc -noout -text -in ~/src/ca/rootCA/private/ca.key.pem 

# Create the root CA certificate:
OpenSSL create certificate chain requires Root and Intermediate Certificate. In this step you'll take the place of VeriSign, Thawte, etc.
Use the Root CA key ca.key.pem to create a Root CA certificate cacert.pem
Give the root certificate a long expiry date. Once the root certificate expires, all certificates signed by the CA become invalid.
Whenever you use the openssl req tool, you must specify a configuration file to use with the -config option, otherwise OpenSSL will default to /etc/ssl/openssl.cnf
We will use v3_ca extensions to create CA certificate

The Common Name (CN) of the CA and the Server certificates must NOT match or else a naming collision will occur and you'll get errors later on.

Use below command to create Root Certificate Authority Certificate cacert.pem. I have specified the Subj inline to the same command, you can update the command based on your environment.

bash

openssl req -passin file:/home/brent/src/ca/mypass.enc \
-config ~/src/ca/openssl_root.cnf \
-key ~/src/ca/rootCA/private/ca.key.pem \
-new -x509 -days 7300 -sha256 -extensions v3_ca \
-out ~/src/ca/rootCA/certs/ca.cert.pem \
-subj "/C=US/ST=Indiana/L=Albion/O=Mobex Global/CN=Root CA"

The CA certificate can be world readable so that it can be used to sign the cert by anyone.

bash
chmod 444 ~/src/ca/rootCA/certs/ca.cert.pem
Execute the below command for openssl verify root CA certificate

bash
openssl x509 -noout -text -in ~/src/ca/rootCA/certs/ca.cert.pem

The output shows:

the Signature Algorithm used
the dates of certificate Validity
the Public-Key bit length
the Issuer, which is the entity that signed the certificate
the Subject, which refers to the certificate itself

The Issuer and Subject are identical as the certificate is self-signed.
The output also shows the X509v3 extensions. We applied the v3_ca extension, so the options from [ v3_ca ] should be reflected in the output.



# Step 4: Generate the intermediate CA key pair and certificate
Create an RSA key pair for the intermediate CA without a password and secure the file by removing permissions to groups and others:

bash
openssl genrsa -des3 -passout file:/home/brent/src/ca/mypass.enc -out ~/src/ca/intermediateCA/private/intermediate.key.pem 4096
chmod 400 ~/src/ca/intermediateCA/private/intermediate.key.pem

## verify key
openssl rsa -passin file:/home/brent/src/ca/mypass.enc -noout -text -in ~/src/ca/intermediateCA/private/intermediate.key.pem 

# Create the intermediate CA certificate signing request (CSR). 
If you are not familiar with the content to be provided with CSR then you should read Things to consider when creating CSR with OpenSSL

bash
https://security.stackexchange.com/questions/252622/what-is-the-purpose-of-certificatepolicies-in-a-csr-how-should-an-oid-be-used
openssl req -passin file:/home/brent/src/ca/mypass.enc \
-config ~/src/ca/openssl_intermediate.cnf \
-key ~/src/ca/intermediateCA/private/intermediate.key.pem \
-new -sha256 -out ~/src/ca/intermediateCA/csr/intermediate.csr.pem -subj "/C=US/ST=Indiana/L=Albion/O=Mobex Global/CN=Intermediate CA"
# note 
# ERROR	OrganizationalUnitName is prohibited if...the certificate was issued on or after September 1, 2022

# Sign the intermediate CSR with the root CA key:
bash
https://www.openssl.org/docs/man1.1.1/man1/ca.html
openssl ca -passin file:/home/brent/src/ca/mypass.enc \
-rand_serial -config ~/src/ca/openssl_root.cnf \
-extensions v3_intermediate_ca \
-days 3650 -notext -md sha256 \
-in ~/src/ca/intermediateCA/csr/intermediate.csr.pem -out ~/src/ca/intermediateCA/certs/intermediate.cert.pem 
## note: 
https://www.openssl.org/docs/man1.1.1/man1/ca.html
The ca command is a minimal CA application. It can be used to sign certificate requests in a variety of forms and generate CRLs it also maintains a text database of issued certificates and their status.

-rand_serial
Generate a large random number to use as the serial number. This overrides any option or configuration to use a serial number file.

# Assign 444 permission to the CRT to make it readable by everyone:
bash
chmod 444 ~/src/ca/intermediateCA/certs/intermediate.cert.pem

# index.txt
The index.txt file is where the OpenSSL ca tool stores the certificate database. Do not delete or edit this file by hand. It should now contain a line that refers to the intermediate certificate.
bash
# cat ~/myCA/rootCA/index.txt
V 330503082700Z 1000 unknown /C=US/ST=California/O=Example Corp/OU=IT Department/CN=Intermediate CA

V: This field indicates the status of the certificate. In this case, V means "Valid." Other possible values are R for "Revoked" and E for "Expired."
330503082700Z: This field represents the expiration date of the certificate in the format YYMMDDHHMMSSZ. In this example, the certificate will expire on 30th May 2033 at 08:27:00 UTC.
1000: This field is the certificate serial number in hexadecimal format.
unknown: This field shows the revocation reason if the certificate has been revoked. For valid certificates, this field usually contains the value "unknown" or is left empty.
/C=US/ST=California/O=Example Corp/OU=IT Department/CN=Intermediate CA: This field contains the subject's distinguished name (DN) in the certificate, which consists of various components such as country (C), state or province (ST), organization (O), organizational unit (OU), and common name (CN). In this example, the DN components are as follows:
C: US
ST: California
O: Example Corp
OU: IT Department
CN: Intermediate CA

## note: 
our serial number is much longer since we used the -rand_serial parameter
Here,
index.txt.attr says subject not unique

# Verify the Intermediate CA Certificate content
bash
openssl x509 -noout -text -in ~/src/ca/intermediateCA/certs/intermediate.cert.pem

# verify certificate
Next openssl verify intermediate certificate against the root certificate. An OK indicates that the chain of trust is intact.

bash
openssl verify -CAfile ~/src/ca/rootCA/certs/ca.cert.pem ~/src/ca/intermediateCA/certs/intermediate.cert.pem
/home/brent/src/ca/intermediateCA/certs/intermediate.cert.pem: OK

# check with linter
https://crt.sh/lintcert

# Step 5: Generate OpenSSL Create Certificate Chain (Certificate Bundle)
To openssl create certificate chain (certificate bundle), concatenate the intermediate and root certificates together.

In the below example I have combined my Root and Intermediate CA certificates to openssl create certificate chain in Linux. We will use this file later to verify certificates signed by the intermediate CA.

bash
cat ~/src/ca/intermediateCA/certs/intermediate.cert.pem ~/src/ca/rootCA/certs/ca.cert.pem > ~/src/ca/intermediateCA/certs/ca-chain-bundle.cert.pem

# verify certificate signature
After openssl create certificate chain, to verify certificate chain use below command:

bash
openssl verify -CAfile ~/src/ca/intermediateCA/certs/ca-chain-bundle.cert.pem ~/src/ca/intermediateCA/certs/intermediate.cert.pem
/home/brent/src/ca/intermediateCA/certs/intermediate.cert.pem: OK

# Step 6: Generate and sign server certificate using Intermediate CA
DONT USE THIS BUT USE SAN CERTIFICATE CREATED IN
openssl-generate-csr-create-san-certificat.md doc
Create a private key for the server:

bash
https://www.openssl.org/docs/manmaster/man1/openssl-genpkey.html
openssl genpkey -des3 -pass file:/home/brent/src/ca/mypass.enc -algorithm RSA -out ~/src/ca/intermediateCA/private/moto.busche-cnc.com.key.pem
chmod 400 ~/src/ca/intermediateCA/private/moto.busche-cnc.com.key.pem
Create a certificate signing request (CSR) for the server:

# create the csr
bash
openssl req -passin file:/home/brent/src/ca/mypass.enc \
-config ~/src/ca/openssl_intermediate.cnf \
-key ~/src/ca/intermediateCA/private/moto.busche-cnc.com.key.pem \
-new -sha256 -out ~/src/ca/intermediateCA/csr/moto.busche-cnc.com.csr.pem


# Sign the server CSR with the intermediate CA:
# I changed the server_cert section from what the author had to match
# the content of the san tutorials server_cert_ext.cnf file
bash
https://www.openssl.org/docs/man1.1.1/man1/ca.html
openssl ca -passin file:/home/brent/src/ca/mypass.enc \
-rand_serial -config ~/src/ca/openssl_intermediate.cnf \
-extensions server_cert -days 375 -notext -md sha256 \
-in ~/src/ca/intermediateCA/csr/moto.busche-cnc.com.csr.pem \
-out ~/src/ca/intermediateCA/certs/moto.busche-cnc.com.cert.pem

The commonName field needed to be supplied and was missing

# Verify the server certificate:
bash
openssl x509 -noout -text -in ~/src/ca/intermediateCA/certs/moto.busche-cnc.com.cert.pem

# Check with linter
https://crt.sh/lintcert